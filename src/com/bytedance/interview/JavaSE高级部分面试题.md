## 并行与并发
- 多个CPU同时执行多个任务。比如：多个人同时做不同的事
- 一个CPU(采用时间片)同时执行多个任务。比如：秒杀、多个人做同一件事

## 线程的创建方式

## 实现线程同步的方式(如何解决线程安全问题？有几种方式？)

## 线程的生命周期

## synchronized与lock的区别

## sleep()和wait()的异同？
- 相同点
  - 一旦执行方法，都可以使得当前的线程进入阻塞状态。
- 不同点：
  - 两个方法声明的位置不一样：Thread类中声明静态sleep()方法，Object类中声明wait()
  - 调用要求不同：sleep()可以在任何需要的场景下调用。wait()必须适应在同步代码块或同步方法中。
  - 关于是否释放同步监视器：如果两个方法都是用在同步代码块或同步方法中，sleep()方法不会释放锁，wait()会释放锁。
  
## 使用线程池的好处
- 提高响应速度
- 降低资源消耗
- 便于线程管理

## String str1 = "abc"; 与 String str2 = new String("abc");的区别

## String、StringBuffer、StringBuilder的区别

## Comparable接口与Comparator的使用的对比：
- Comparable接口的方式一旦一定，保证Comparable接口实现类的对象在任何位置都可以比较大小。
- Comparator接口属于临时性的比较。

## ArrayList、LinkedList、Vector的异同点

## 谈谈你对HashMap中put/get方法的认识？如果了解再谈谈HashMap的扩容机制？默认大小是多少？什么是负载因子(或填充比)？什么是吞吐临界值(或阈值、threshold)？

## 负载因子值的大小，对HashMap有什么影响
- 负载因子的大小决定了HashMap的数据密度。
- 负载因子越大密度越大，发生碰撞的几率越高，数组中的链表越容易长,造成查询或插入时的比较次数增多，性能会下降。
- 负载因子越小，就越容易触发扩容，数据密度也越小，意味着发生碰撞的几率越小，数组中的链表也就越短，查询和插入时比较的次数也越小，性能会更高。但是会浪费一定的内容空间。而且经常扩容也会影响性能，建议初始化预设大一点的空间。
 按照其他语言的参考及研究经验，会考虑将负载因子设置为0.7~0.75，此时平均检索长度接近于常数